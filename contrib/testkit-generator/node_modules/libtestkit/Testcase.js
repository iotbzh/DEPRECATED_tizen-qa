/*
 * TKIT Testcase class
 * Authors: Stéphane Desneux <sdx@kooltux.org>
			Nicolas Zingilé <nicolas.zingile@open.eurogiciel.org>
 * Date: 2013-01-10
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var path=require("path");

var logger=log4js.getLogger("tkitcase");

var TKIT=require('libtestkit');

var DEBUG=false;

/*
default values of the testcase definition
*/
var deftcconfig = {
    name: null, // mandatory
    priority: 4, // 0-?
    status: "designed", // designed|ready|approved|disabled
    type: null, // functional_positive|functional_negative|security|performance|reliability|portability|maintainability|user_experience|compliance|undefined
    subtype: null, // power|memory|cpu|io|network|undefined

    objective: "",
    description: "",
    onload_delay: "", // this field can appear in the wapapi testcases
    exec_type: "auto", // auto|manual
    exec_pre: "", 
    exec: null, // "localfile.sh 10" |localfile.py|...
    exec_expected_retcode: 0,
    exec_kill_timeout: 120, // <seconds|undefined>
    exec_post: "",

	author: "",
};

/*
listing of valid values
*/
var defvalidvals = {
    status: "designed|ready|approved|disabled",
    exec_type: "auto|manual",
    type: "functional_positive|functional_negative|security|performance|reliability|portability|maintainability|user_experience|compliance",
    subtype: "power|memory|cpu|io|network"
};

{ for(var f in defvalidvals) defvalidvals[f] = defvalidvals[f].split("|"); }

/*
Check the values of the test definition.
*/
function check(obj) {
    function fail(field,msg) {
	throw new Error("Invalid testcase "+obj.id+", field '"+field+"': "+msg);
    }
    function check_string(obj,field) {
	if (!(field in obj)) 
	    fail(field,"isn't set.");
	if (typeof obj[field]!='string') 
	    fail(field,"isn't a String.");
    }
    function check_number(obj,field) {
	if (!(field in obj)) 
	    fail(field,"isn't set.");
	if (typeof obj[field]=='string') {
	    var v = parseInt(obj[field]);
	    if (!isNaN(v)) obj[field]=v;
	}
	if (typeof obj[field]!='number') 
	    fail(field,"isn't a Number.");
    }
    function check_integer(obj,field) {
	check_number(obj,field);
	if (obj[field]!=Math.floor(obj[field]))
	    fail(field,"isn't an integer value.");
    }
    function check_not_empty_string(obj,field) {
	check_string(obj,field);
	if (obj[field]=='') 
	    fail(field,"is an empty string.");
    }
    function check_string_in(obj,field) {
	check_string(obj,field);
	if(defvalidvals[field].indexOf(obj[field]) < 0)
	    fail(field,"isn't in the set '"+defvalidvals[field].join("', '")+"'.");
    }
    function check_opt_string_in(obj,field) {
	if (!(field in obj)) return;
	if (obj[field]==undefined) return;
	if (obj[field]=='') return;
	check_string_in(obj,field);
    }
    function check_range(obj,field,low,upp) {
	if (obj[field]<low || obj[field]>upp)
	    fail(field,"isn't in the range "+low+" .. "+upp);
    }
    function check_number_range(obj,field,low,upp) {
	check_number(obj,field);
	check_range(obj,field,low,upp);
    }
    function check_integer_range(obj,field,low,upp) {
	check_integer(obj,field);
	check_range(obj,field,low,upp);
    }

    check_not_empty_string(obj,'name');
    check_string_in(obj,'status');
    check_string_in(obj,'exec_type');
    check_opt_string_in(obj,'type');
    check_opt_string_in(obj,'subtype');
    check_integer_range(obj,'priority',0,100); // arbitrary to 100

    if (obj.exec_type == 'auto') {
	check_not_empty_string(obj,'exec');
	check_integer_range(obj,'exec_expected_retcode',0,127);
	check_integer_range(obj,'exec_kill_timeout',0,864000); // 10 days!
    }
}

/*
Builds a Testcase object.
Parameters:
 - testset (Object: TKIT.Testset): the testset that records this test case.
 - tcasenum (Number): the testcase number inside the testset.
 - definition (Object): the definition the the testcase.
      It may contains any field name but the normalized ones are
	name, priority, status, type, subtype, objective, description, onload_delay, notes,
	bugs, steps, exec_type, exec_pre, exec, exec_expected_retcode,
	exec_kill_timeout, exec_post
      The mandatory one are 'name' and 'exec'.
 - 'filename' (String): the filename within the directory containing the testcase
The built object contains all the fields listed above plus:
 - testset (Object: TKIT.Testset): the given testset
 - name (String): the redefined name as XX-name wher XX is the base 36 encoded 
                  testcase number.
*/
var Testcase=module.exports=function(testset,tcasenum,definition,filename) {
	if (!(testset instanceof TKIT.Testset)) {
		throw new Error("Testcase: invalid parent (not a Testset)");
	}

	_.defaults(_.extend(this,definition),deftcconfig);

	this.testset=testset;
	this.tcasenum=tcasenum;
	this.name=TKIT.utils.encodeName(tcasenum,this.name);
	this.filename=filename;
	this.id = testset.getId()+"-"+this.name;
	this.addedServices=[];

	check(this);

	DEBUG && logger.debug("Testcase "+this.name+" created on component "+this.getComponentName());
}

/*
Static function to return a default testcase
*/
Testcase.GetDefault=function() {
	var tc=_.extend({},deftcconfig);

	// add author/mtime/ctime
	tc.author=process.env.USER;

   var dt=new Date();
   function pad(s,n) { s=String(s); var x=""; for (var i=0; i<n-s.length; i++) { x+="0"; }; return x+s; }
   tc.ctime=
      [
         dt.getUTCFullYear(),
         pad(dt.getUTCMonth()+1,2),
         pad(dt.getUTCDate(),2)
      ].join("-")+
      " "+
      [
         pad(dt.getUTCHours(),2),
         pad(dt.getUTCMinutes(),2),
         pad(dt.getUTCSeconds(),2)
      ].join(":")+
      " "+
      "GMT"
   ;

	tc.mtime=tc.ctime;

	return tc;
}

/*
Returns an object suitable for display or export
*/
Testcase.prototype.toExportable=function() {
	function t(x){ return String(x).trim(); }
	var obj={
		id:							this.getId(),
		author:						t(this.author),
		component:					this.getComponentName(),
		pathname: 					this.getDirPath(),
		shortname:					TKIT.utils.stripName(this.name),
		fullname:					this.getComponentName() + "/" + TKIT.utils.stripName(this.name),
		name:						this.name,
		priority:					this.priority,
		status:						this.status,
		type:						this.type + (this.subtype ? ("/"+this.subtype) : ""),
		objective:					t(this.objective),
		description:				t(this.description),
		onload_delay:				t(this.onload_delay),
		exec_type:					this.exec_type,
		exec_pre:					this.exec_pre,
		exec:						this.exec,
		exec_expected_retcode:		this.exec_expected_retcode,
		exec_kill_timeout:			this.exec_kill_timeout,
		exec_post:					this.exec_post
	};

	return obj;
}

/*
Returns the relative path of the file defining the testcase.
*/
Testcase.prototype.getFilename=function(prefix) {
	return path.join(this.testset.getDirPath(prefix),this.filename);
}

/*
Returns the relative path of the directory of the testcase.
*/
Testcase.prototype.getDirPath=function(prefix) {
	return this.testset.getDirPath(prefix);
}

/*
Returns the exec path within the directory of the testcase.
*/
Testcase.prototype.getExecPath=function(prefix) {
	return this.testset.getExecPath(prefix);
}

/*
Return the component name of the testcase
*/
Testcase.prototype.getComponentName=function() {
	return this.testset.getComponentName();
}

/*
Return the id of the testcase
*/
Testcase.prototype.getId=function() {
	return this.id;
}

/*
Transform an 'array' containing string or array (recurssively) to 
a string of the joined strings serparated with 'sep'.
*/
function toScript(array,sep){
	return array.map(function(x){
		return (x instanceof Array) ? toScript(x,this) : x;
	    },sep)
	    .filter(TKIT.utils.fnes)
	    .join(sep);
}

/*
Return the script
*/
Testcase.prototype.getScript=function(prefix,sep) {
	return toScript([
		// set working directory and path
		'cd '+this.getDirPath(prefix),
		'export QAPATH="'+this.getExecPath(prefix)+'"',
		'export PATH="$QAPATH:$PATH"',

		// before test
		this.__service_hook('beforePreScript'),
		this.exec_pre,
		this.__service_hook('beforeExecScript'),

		// exec the test
		this.exec,
		'rc=$?',

		// after test
		this.__service_hook('afterExecScript'),
		this.exec_post,
		this.__service_hook('afterPostScript'),

		// returns the test status
		'exit $rc'
	],sep||"\n");
}

/*
Add to the list of services the 'service' with its optional 'params'.
*/
Testcase.prototype.addService=function(service,params){
	logger.info("Adding service {"+service.getName()+"} for testcase "+this.getId());
	this.addedServices.push({'service':service,'params':params});
}

/*
Returns an array containing the scripted hook of the added services.
'hook' is the name of the hook wanted. Currently, valid values for 
'hook' are:
 - 'beforePreScript'
 - 'beforeExecScript'
 - 'afterExecScript'
 - 'afterPostScript'
*/
Testcase.prototype.__service_hook=function(hook){
	return this.addedServices.map(function(x){
		var s=x.service, f=s[hook];
		if(typeof f == 'function')
			return f.call(s,this,x.params);
	},this);
}


