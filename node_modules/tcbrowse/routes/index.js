/*
All the pages and actions of TCBROWSE are served by this simple script.
-----------------------------------------------------------------------
authors: José Bollo <jobol@nonadev.net>, Stéphane Desneux <sdx@kooltux.org>
*/
var fs	 = require('fs')
  , _    = require('underscore')
  , exec = require('child_process').exec
  ;

// the root QA DB directory
var qa_db_dir = process.env.QADBDIR || './db';

// the default test case template
var defaultTC = {
    name: '', // mandatory
    priority: 4, // 0-?
    status: "designed", // designed|ready|approved|disabled
    type: 'functional_positive', // functional_positive|functional_negative|security|performance|reliability|portability|maintainability|user_experience|compliance|undefined
    subtype: '', // power|memory|cpu|io|network|undefined

    objective: "",
    description: "",
    notes: "",
    bugs: "",
	 pre_condition: "",
	 steps: [],
	 post_condition: "",

    exec_type: "manual", // auto|manual
    exec_pre: "", 
    exec: '', // "localfile.sh 10" |localfile.py|...
    exec_expected_retcode: 0,
    exec_kill_timeout: 120, // <seconds|undefined>
    exec_post: "",
    service: {},

	 author:"",
	 ctime:"",
	 mtime:""
};

// regular expression to match valid directories
var regexdir = /^[0-9A-Z][0-9A-Z]-/;

// stringify the test case 'tc' in a standard way
function tcjson(tc) {
    return JSON.stringify(tc,null,"  ");
}

// returns the timestamp of now formated as 'YYYY-MM-DD HH:MM:SS GMT'
function now() {
	function pad(s,n) {
		s = String(s); 
		while (s.length < n) s = "0" + s;
		return s; 
	    };

	var dt=new Date();
	return [
			dt.getUTCFullYear(),
			pad(dt.getUTCMonth()+1,2),
			pad(dt.getUTCDate(),2)
		].join("-")+
		" "+
		[
			pad(dt.getUTCHours(),2),
			pad(dt.getUTCMinutes(),2),
			pad(dt.getUTCSeconds(),2)
		].join(":")+
		" GMT";
}

// returns the current author
function author() {
	return process.env.USER;
}

// emulation of function 'fs.existsSync' if needed
if (!('existsSync' in fs))
fs.existsSync = function(path){
    try { fs.statSync(path); return true; } catch(e) { return false; }
};

/**********************************************
** Generate the root page
**********************************************/
exports.index = function(req, res){
    if (fs.statSync(qa_db_dir).isDirectory()) {
	// the root QA DB directory exists
	// 
	var i, entry, entries, path, dirs = [];
	entries = fs.readdirSync(qa_db_dir);
	for(i in entries) {
	    entry = entries[i];
	    if (entry.match(regexdir)) {
		path = qa_db_dir+'/'+entry;
		if (fs.statSync(path).isDirectory())
		    dirs.push({
			href: '/dir/'+entry, 
			name: entry
		    });
	    }
	}
	dirs.sort(function(x,y){return x.name.localeCompare(y.name);})
	res.render('index', { title: 'QA Browser', dirs: dirs });
    } else { 
	// the root QA DB directory doesn't exist => error
	res.send("not available");
    }
};

/**********************************************
** Generate a directory page
**********************************************/
exports.dir = function(req,res){
    var dir = String(req.params);
    var lroot = qa_db_dir + '/' + dir;
    var droot = '/dir/'+dir+'/';
    var mroot = '/meta/'+dir+'/';
    if (fs.statSync(lroot).isDirectory()) {
	var i, n, dirs, p, sdirs=[], metas=[];
	p = dir.split('/').slice(0,-1).join('/');
	parentdir={href: (p ? '/dir/'+p : '/'), name: 'PARENT'};
	content = fs.readdirSync(lroot);
	for(i in content) {
	    n = content[i];
	    if (n.match(regexdir)) {
		p = lroot+'/'+n;
		if (fs.statSync(p).isDirectory())
		    sdirs.push({href:droot+n,name:n});
	    }
	    else if (n.match(/^QAMETA.*\.json$/)) {
		metas.push({href:mroot+n,name:n});
	    }
	}
	sdirs.sort(function(x,y){return x.name.localeCompare(y.name);})
	sdirs.unshift(parentdir); // insert at the beginning, after sort

	metas.sort(function(x,y){return x.name.localeCompare(y.name);})
	res.render('dir', { title: 'QA Browser: '+dir, dir: dir, dirs: sdirs, metas: metas, post: '/dpost/'+dir });
    } else { 
	res.send("not available");
    }
}

/**********************************************
** Generate a meta page
**********************************************/
exports.meta = function(req,res){
    var file = String(req.params);
    var path = qa_db_dir + '/' + file;
    if (fs.statSync(path).isFile()) {
	var content = fs.readFileSync(path);
	try {
	    var defs = JSON.parse(content);
	    if (!(defs instanceof Array)) defs = [ defs ];
		 defs.forEach(function(d) {
		 	d=_.defaults(d,defaultTC);
		 });
	    var up = file.split('/').slice(0,-1).join('/');
	    up = { href: '/dir/'+up, name: up };
	    res.render('meta', { title: 'QA Browser: '+file, file: file, up: up, defs: defs, post: '/mpost/'+file });
	}
	catch(e) {
	    res.send("invalid test case definition: "+e);
	}
    } else { 
	res.send("not available");
    }
}

/**********************************************
** Receive a post for an action at meta level
**********************************************/
exports.mpost = function(req,res){
    var file = String(req.params);
    var path = qa_db_dir + '/' + file;
    var redi = '/meta/' + file;
    var a = req.query.a;
    try {
	var n = ("n" in req.query) ? req.query.n-0 : undefined;
	var prev;
	var content = fs.readFileSync(path);
	// get original data
	var defs = JSON.parse(content);
	if (!(defs instanceof Array)) defs = [ defs ];

	// normalize entry
	var f, u;
	for(f in req.body) {
	    u=req.body[f];
	    if((typeof u == 'string') && (u[0]=='{' || u[0]=='[')) {
		try {
		    req.body[f] = JSON.parse(u);
		}
		catch(e) {
		    req.body[f] = u;
		}
	    }
	}
	// do nothing if already an array)
	var steps=(req.body.steps||"").split(/\r?\n/);
	req.body.steps=steps.map(function(s) {
		s=s.trim();
		if (!s.length) return;

		var so={};
		var elts=s.split("=>");
		so.description=(elts.length ? elts.shift().trim() : '');
		so.expected=elts.filter(function(x) { return x.length>0;}).join("=>").trim();
		return so;
	}).filter(function(x){return x;});

	switch(a) {
	case 'gu': // action=go up
	    if (!(n in defs) || n==0)
		throw "Invalid Index";

	    prev=defs[n];
	    defs[n] = defs[n-1];
	    defs[n-1] = prev;
	    redi = redi+"#"+(n-1);
	    break;
	case 'gd': // action=go down
	    if (!(n in defs) || n+1==defs.length)
		throw "Invalid Index";

	    prev=defs[n];
	    defs[n] = defs[n+1];
	    defs[n+1] = prev;
	    redi = redi+"#"+(n+1);
	    break;
	case 'm': // action=modify
	    if (!(n in defs))
		throw "Invalid Index";

		 // keep previous author,ctime,mtime
		 prev=defs[n];

	    defs[n] = req.body;
	    redi = redi+"#"+n;

		 // update mtime and author
		 defs[n].author=author();
		 defs[n].ctime=prev.ctime || now();
		 defs[n].mtime=now();
	    break;
	case 'c': // action=clone

	    req.body.name += "-cloned";
	    defs.splice(++n,0,req.body);
	    redi = redi+"#"+n;

		 // update mtime and author
		 defs[n].author=author();
		 defs[n].ctime=now();
		 defs[n].mtime=now();
	    break;
	case 'd': // action=delete
	    if (!(n in defs))
		throw "Invalid Index";
	    defs.splice(n,1);
	    break;
	case 'n': // action=new
	    redi = redi+"#"+defs.length;
	    defs.push(defaultTC);

		 // add ctime,mtime and author 
		 n = defs.length - 1;
		 defs[n].author=author();
		 defs[n].ctime=now();
		 defs[n].mtime=now();
		 // TODO
	    break;
	default:
	    throw "Invalid Action "+a;
	}

	fs.writeFileSync(path,tcjson(defs));
	res.redirect(redi);
    }
    catch(e) {
	res.set("refresh", "30;url="+redi);
	res.send("<pre>ERROR: "+String(e)+"\n\n"+e.stack+"</pre>");
	return;
    }
}


/**********************************************
** Receive a post for an action at directory level
**********************************************/
exports.dpost = function(req,res){
    var dir = String(req.params);
    var path = qa_db_dir + '/' + dir;
    var redi = '/dir/' + dir;
    var a = req.query.a;
    var n = req.query.n;
    var e = req.body.entry
    var p;
    try {
	switch(a) {
	case 'nd':
	    if (!e.match(regexdir))
		throw "Bad directory name";
	    p = path+'/'+e;
	    if (fs.existsSync(p))
		throw "Name already exists";
	    fs.mkdirSync(p);
	    if (!fs.existsSync(p))
		throw "Can't create directory";
	    if (!fs.statSync(p).isDirectory()) 
		throw "Internal error";
	    break;
	case 'nt':
	    p = path+'/QAMETA'+e+'.json';
	    if (fs.existsSync(p))
		throw "Name already exists";
	    fs.writeFileSync(p,tcjson([defaultTC]));
	    if (!fs.existsSync(p))
		throw "Can't create testcase";
	    if (!fs.statSync(p).isFile()) 
		throw "Internal error";
	    break;
	case 'co':
	    p = path+'/'+n;
	    if (!fs.existsSync(p))
		throw "File "+p+" doesn't exists";
	    n=n.replace(/"/g,"\\\"");
	    e=e.replace(/"/g,"\\\"");
	    var cmd = 'cd '+path+' && git add '+n+' && git commit -o -m "'+e+'" -- '+n;
	    exec(cmd,function(err,stdout,stderr){
		    if (err===null)
			res.redirect(redi);
		    else {
			res.set("refresh", "3;url="+redi);
			res.send("<pre>ERROR!\n"+cmd+"\n\nstdout:\n"+String(stdout)+"\nstderr:\n"+String(stderr)+"</pre>");
		    }
		});
	    return;
	default:
	    throw "Invalid Action "+a;
	}
	res.redirect(redi);
    }
    catch(e) {
	res.set("refresh", "3;url="+redi);
	res.send("<pre>ERROR: "+String(e)+"</pre>");
	return;
    }
}



