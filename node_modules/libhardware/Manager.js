/*
 * QA Hardware library - Manager class
 * Author: St√©phane Desneux <sdx@kooltux.org>
 * Date: 2013-04-15
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var path=require("path");
var fs=require('fs');
var child_process=require('child_process');

var logger=log4js.getLogger("hardware");

var HW=require('libhardware');

var DEBUG=false;

var GLOBALS={
	config_file: "hwtargets.conf",
	dnsmasq_hosts: "dnsmasq.qa.hosts", // referenced in dnsmasq.conf
	dnsmasq_dhcp: "dnsmasq.qa.dhcp", // referenced in dnsmasq.conf
	cats_devdir: "/opt/cats/cats_db/devices"
};

var Manager=module.exports=function(configdir) {
	// resolve to abs path
	configdir=path.resolve(configdir); 

	// check config dir
	if (!fs.statSync(configdir).isDirectory())
		throw new Error("Invalid config dir '"+configdir+"'");

	this.configdir=configdir;
	this.configfile=path.join(configdir,GLOBALS.config_file);

	this.loadDevices();
}

Manager.prototype.loadDevices=function() {
	logger.info("Opening config file "+this.configfile);

	var content=fs.readFileSync(this.configfile);
	if (!content) {
		throw new Error("Invalid config file "+this.configfile);
	}

	try {
		content=JSON.parse(content);
	}
	catch(e) {
		logger.error("Unable to parse config file "+this.configfile+": "+e);
		throw e;
	}

	if (typeof content != 'object') {
		logger.error("Invalid configuration in "+this.configfile+" (not an object as expected)");
		throw new Error("Invalid configuration "+this.configfile);
	}

	this.devices={};
	this.removed_devices={};
	_.keys(content).forEach(function(devid) {
		// NB: the device id is added into definition
		this.devices[devid]=new HW.Device( _.extend({id:devid},content[devid]));
	},this);

	logger.info(_.keys(this.devices).length+" devices definitions loaded");
}

Manager.prototype.forEachDevice=function(cb,binding) {
	_.keys(this.devices).forEach(function(id) {
		var dev=this.devices[id];
		cb(dev);
	},binding || this);
}

Manager.prototype.getDevices=function() {
	var obj={};
	this.forEachDevice(function(dev) {
		obj[dev.id]=dev.definition();
		obj[dev.id].id=dev.id; // add id inside object
	});
	return obj;
}

Manager.prototype.getDeviceById=function(id) {
	if (id in this.devices)
		return this.devices[id];
	return null;
}

Manager.prototype.getDeviceByHostname=function(hostname) {
	var found=null;
	_.values(this.devices).some(function(dev) {
		if (dev.hostname == hostname) {
			found=dev;
			return true;
		}
	});
	return found;
}

Manager.prototype.getDeviceByIp=function(ip) {
	var found=null;
	_.values(this.devices).some(function(dev) {
		if (dev.ip_address == ip) {
			found=dev;
			return true;
		}
	});
	return found;
}

Manager.prototype.getDeviceByMac=function(mac) {
	var found=null;
	mac=mac.toLowerCase();
	_.values(this.devices).some(function(dev) {
		if (dev.mac_address == mac) {
			found=dev;
			return true;
		}
	});
	return found;
}

Manager.prototype.addDevice=function(opts) {
	var dev=new HW.Device(opts);

	// check for duplicate id, hostname, ip, mac
	_.values(this.devices).some(function(odev) {
		['id','hostname','mac_address','ip_address'].forEach(function(k) {
			if (dev[k] == odev[k]) {
				throw new Error("Duplicate "+k+" detected: a device with "+k+"='"+dev[k]+"' is already defined");
			}
		},this);
	},this);

	this.devices[dev.id]=dev;

	logger.info("Device "+dev.id+" added");

	return true;
}

Manager.prototype.removeDevice=function(id) {
	if (id instanceof HW.Device)
		id=id.id;
		
	if (id in this.devices) {
		this.removed_devices[id]=this.devices[id]; // keep for writing conf appropriately
		delete this.devices[id];
		logger.info("Device "+id+" removed");
		return true;
	}

	return false;
}

Manager.prototype.saveDevices=function(restricted) {
	var buf;
	var output;

	// save to hwtargets.conf
	output=this.configfile;
	var obj={};
	this.forEachDevice(function(dev) {
		obj[dev.id]=dev.definition();
	});
	fs.writeFileSync(output,JSON.stringify(obj,null,"   "));
	logger.info(output+" generated successfully");

	// regenerate dnsmasq host file
	buf=[];
	output=path.join(this.configdir,GLOBALS.dnsmasq_hosts);
	buf.push([
		"# #### this file was generated from "+this.configfile+" by the qatarget command ####",
		"#",
		"# Don't edit this file manually, but use: qatarget <add|remove> <args>",
		""
	].join("\n"));

	this.forEachDevice(function(dev) {
		buf.push(dev.ip_address+" "+dev.hostname);
	});
	buf.push(""); // last \n
	fs.writeFileSync(output,buf.join("\n"));
	logger.info(output+" generated successfully");

	// regenerate dnsmasq dhcp file
	buf=[];
	output=path.join(this.configdir,GLOBALS.dnsmasq_dhcp);
	buf.push([
		"# #### this file was generated from "+this.configfile+" by the qatarget command ####",
		"#",
		"# Don't edit this file manually, but use: qatarget <add|remove> <args>",
		"#",
		"# IMPORTANT: always set net:qatarget-boot to machine state",
		"# only the machine with this state will be considered as test machines",
		"# this is to avoid unattended flashes on non identified hardware targets",
		""
	].join("\n"));

	this.forEachDevice(function(dev) {
		buf.push([
			dev.mac_address,
			"net:qatarget-boot", // set in dnsmasq.conf
			dev.hostname
		].join(" , "));
	});
	buf.push(""); // last \n
	fs.writeFileSync(output,buf.join("\n"));
	logger.info(output+" generated successfully");

	var commands=[];
	if (!restricted) {
		// remove files for removed_devices in CATS dir
		_.keys(this.removed_devices).forEach(function(devid) {
			var file=path.join(GLOBALS.cats_devdir,this.removed_devices[devid].ip_address);
			try {
				fs.unlinkSync(file);
			}
			catch(e) {}
			delete this.removed_devices[devid];
			logger.info(file+" removed successfully");
		},this);

		// update CATS devices
		this.forEachDevice(function(dev) {
			var devfile=path.join('/tmp',dev.ip_address);
			buf=[
				"[DEVICE]",
				"; this file was generated by the qatarget command from qatizen tools",
				"platform = "+dev.platform,
				"product = "+dev.product,
				"ip = "+dev.ip_address,
				"state = FREE",
				"label = share"
			].join("\n");

			// write in cats device file
			fs.writeFileSync(devfile,buf);

			commands.push("/usr/bin/mv "+devfile+" "+GLOBALS.cats_devdir);

			commands.push("/usr/bin/chown cats:users "+devfile);
			commands.push("/usr/bin/chmod 644 "+devfile);

			logger.info(devfile+" generated successfully");
		});

		// restart dnsmasq to take new files into account
		commands.push("/bin/systemctl restart dnsmasq.service");
	}

	// exec pending commands

	commands.forEach(function(cmd) {
		logger.info("Running subcommand: "+cmd);
		child_process.exec("sudo "+cmd,function(err,stdout,stderr) {
			if (err) {
				logger.error("Subcommand failed:");
				logger.error("   "+cmd);
				logger.error("stdout:\n---\n"+stdout+"\n---");
				logger.error("stderr:\n---\n"+stderr+"\n---");
			}
		});
	},this);

	return true;
}
