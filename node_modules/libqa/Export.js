/*
 * QA Export class
 * Author: St√©phane Desneux <sdx@kooltux.org>
 * Date: 2013-02-06
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var path=require("path");
var fs=require('fs');
var strftime=require('strftime').strftimeUTC;
var mkdirp=require('mkdirp');

var logger=log4js.getLogger("qaexport");

var QA=require('libqa');

var DEBUG=false;

/* globals */
var CONFIG=null;

/*
MANAGEMENT OF EXPORT PLUGINS
============================

*/
var methodsCheck = {
	setId: true,
	getFilename: true,
	setOutput: false,
	execute: true
};

/* -------------------- helper functions ---------------- */

/*
Returns true if 'item' has the 'method'.
*/
function hasMethod(item,method){
	return 'function' == typeof item[method];
}

/*
If the 'item' has the 'method', call the 'method'
with the remaining arguments and this set to 'item'.
*/
function callopt(item,method){
	var f=item[method];
	if ('function' == typeof f)
		return f.apply(item,Array.prototype.slice.call(arguments,2));
}

/* -------------- Export class --------------------- */
 
var Export=module.exports=function(opts) {
	var cfg=_.extend({
		configdir: null, 		// mandatory (where are the config files ?)
		name: "default", 		// optional (how to export: from etc/qaexport.conf)
		profile: null, 		// mandatory (what to test: from etc/test_suites.conf)
		dbdir: null ,			// mandatory (top db dir)
		output: QA.GLOBALS.local_tempdir // optional output dir
	},opts);
	DEBUG && logger.debug("Creating QA Export with options: "+util.inspect(cfg));

	// instanciate config object
	CONFIG=new QA.Config(cfg.configdir);

	// check export name
	if (!(cfg.name in CONFIG.EXPORTS)) 
		throw new Error("Export name '"+cfg.name+"' not found in config");
	this.name=cfg.name;

	// get plugin
	if (!('plugin' in CONFIG.EXPORTS[this.name]))
		throw new Error("Export '"+cfg.name+"' has no plugin (check config)");
	this.pluginName=CONFIG.EXPORTS[this.name].plugin;

	// load plugin
	this.pluginClass=this._get_plugin(this.pluginName);
	this.pluginOptions=_.extend({},CONFIG.EXPORTS[this.name]); // copy object
	delete this.pluginOptions['plugin']; // remove plugin name (unused in instance)
	// the remaining properties are considered as instance options

	// output dir or file
	this.output=cfg.output;

	// check profile
	if (!(cfg.profile in CONFIG.PROFILES)) 
		throw new Error("Profile '"+cfg.profile+"' not found in config");
	this.profile=_.extend({
		filter: function(testcase) { return true; }
	},CONFIG.PROFILES[cfg.profile]);
	this.profile.id=cfg.profile; // store id key inside object

	// generate id 
	this.id=[
		this.name,
		this.profile.id,
		strftime("%Y%m%d_%H%M%SU")
	].join("_");

	// init database with dbdir
	this.db=new QA.Database(cfg.dbdir);

	// dry run flag
	this.dryrun=false;
}

/* ----------------------- methods --------------------- */

Export.prototype._get_title=function(){
	return this.profile.title ? this.profile.title :
		// generate default title
		[
			"Testsuite export: ",
			QA.utils.splat(this.profile.suite).join("+"),
			"-",
			strftime("%Y-%m-%d %H:%M UTC"), // 2013-01-22 
		].join(" ");
}

Export.prototype._get_plugin=function(name){
	name=name.toUpperCase();

	var klass;
	logger.info("Loading export plugin: "+name);
	try {
		klass=require("./exports/"+name+".js");
	}
	catch(e){
		throw new Error("Can't get export plugin '"+name+"'\nReason: "+e.toString());
	}

	DEBUG && logger.debug("Loaded export plugin: "+name);
	
	for(var m in methodsCheck) {
		if (methodsCheck[m] && !hasMethod(klass.prototype,m))
			throw new Error("Bad export plugin: mandatory method '"+m+"' isn't defined.");
	}

	return klass;
}

Export.prototype.enableDryRun=function() {
	this.dryrun=true;
}

Export.prototype.execute=function(cb) {
	logger.info("Export with options:\n"+util.inspect(this));

	/* create the testsuite */
	var testsuite=new QA.Testsuite(this.db,this.profile.suite,this.profile.filter);
	if(testsuite.isEmpty()) {
		throw new Error("No test case selected for the selected profile '"+this.profile.id+
				"' - suggestion: change filters in "+path.join(this.configdir,"test_suites.conf"));
	}

	var xport=new this.pluginClass(this.pluginOptions);

	callopt(xport,'setId',this.id);
	callopt(xport,'setOutput',this.output);

	xport.execute(testsuite,_.bind(function(buf) {
		// check if exist
		function isdir(x) {
			try {
				return fs.statSync(x).isDirectory();
			}
			catch(e) {
				return false;
			}
		}

		if (this.output == "stdout") { // workaround: optimist can't parse '-' as a string => use 'stdout'
			outfile="-";
		}
		else if (isdir(this.output)) {
			outfile=path.join(this.output, xport.getFilename());
		}
		else if (isdir(path.dirname(this.output))) {
			outfile=this.output;
		}
		else {
			throw new Error("Export output '"+this.output+"' can't be created");
		}

		logger.info("Output file created: "+outfile);

		if (outfile=="-") {
			process.stdout.write(buf);
		}
		else {
			fs.writeFileSync(outfile,buf);
		}
	},this));
}

