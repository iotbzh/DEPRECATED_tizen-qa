/*
 * QA service Http class
 * Author: Jose Bollo <jobol@nonadev.net>
 * Date: 2013-01-30
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var path=require("path");
var http=require("http");
var url=require('url');
var fs=require('fs');
var mime=require('simple-mime')('application/octect-stream');

var logger=log4js.getLogger("qasrvhttp");

var QA=require('libqa');

var DEBUG=false;

var STATES={
	off: 'off',
	enabled: 'enabled',
	starting: 'starting',
	error: 'error',
	on: 'on'
};

/*
Creates the service 
*/
var Me=module.exports=function(manager,name) {
	logger.info("Activation of the service HTTP");
	this.manager=manager;
	this.name=name;
	this.config=_.extend({host:"localhost",port:0},QA.GLOBALS.service_http);
	this.server=null;
	this.state=STATES.off;
	this.baseurl="http://"+this.config.host+":"+this.config.port+"/";
	this.dir=manager.getDir();
}

/*
Returns the name of the service.
*/
Me.prototype.getName=function(){
	return this.name;
}

/*
Returns the description of the service.
*/
Me.prototype.describe=function(){
	return '{ Service '+this.name+': state='+this.state+' baseurl='+this.baseurl+' }';
}

/*
Set the required 'spec' of service for the testcase 'tc'.
 - 'spec' (Any): is something telling the requiring of service.
 - 'tc' (QA.Testcase): is the testcase that requires the service
*/
Me.prototype.addTestcase=function(spec,tc){
	if(spec===false) return;
	if(spec===true) spec={enable:true}
	if(!spec.enable) return;
	this.activate();
	tc.addService(this);
}

Me.prototype.activate=function(){
	if (this.state===STATES.off) {
		logger.info("Enabling "+this.describe());
		this.state=STATES.enabled;
	}
}

/*
*/
Me.prototype.start=function(cb){
	if (this.state===STATES.enabled) {
		this.state=STATES.starting;
		logger.info("Starting "+this.describe());
		this.server=new http.Server();
		this.server.on('request',requesting.bind(this));
		this.server.on('listening',(function(){
			    this.state=STATES.on;
			    var host=this.config.host;
			    var port=this.server.address().port;
			    this.baseurl="http://"+host+":"+port+"/";
			    logger.info(this.describe()+' is now listening');
			    cb(0);
		    }).bind(this));
		this.server.on('error',(function(e){
			    if(this.state===STATES.starting){
				    this.state=STATES.error;
				    logger.info('Error on '+this.describe()+": "+e.toString());
				    cb(1);
			    }
		    }).bind(this));
		this.server.listen(this.config.port,this.config.host);
	}
	else {
	    cb(0);
	}
}

/*
*/
Me.prototype.stop=function(cb){
	logger.info("Stopping "+this.describe());
	if(this.state!==STATES.off) {
		this.server.close();
		this.state=STATES.off;
	}
	cb();
}

/*
*/
/*
Export for the testcase 'tc' the base url for the directory before prepare script.
*/
Me.prototype.beforePreScript=function(tc){
	return 'export QA_HTTP_BASEURL="'+encodeURI(this.baseurl+tc.getDirPath())+'"';
}

function requesting(request,response){
	var h=""; for(var i in request.headers)h+=i+": "+request.headers[i]+"\n";
	logger.info(this.describe()+" request of "+request.url+" HEADERS={\n"+h+"}");

	var u=url.parse(request.url);
	var f=path.join(this.dir,u.pathname);

	fs.stat(f,function(err,s){

		if (err || !s.isFile()) {
			response.writeHead(404,"file not found");
			response.end();
			return;
		}

		if (!('range' in request.headers)) {
			response.writeHead(200, {
				'Content-Length': s.size,
				'Content-Type': mime(f) });
			if (request.method == 'HEAD') {
				response.end();
				return;
			}
			var stream=fs.createReadStream(f);
			stream.on('data',function(data){ response.write(data); });
			stream.on('end',function(){ response.end(); });
			stream.on('error',function(e){ response.end(); });
		}
		else {
			var x = /bytes=(\d+)-(\d*)/.exec(request.headers.range);
			if (x === null) {
				response.writeHead(400,"range malformed");
				response.end();
				return;
			}
			else {
				var size=s.size, first=parseInt(x[1]), last=(x[2]==""?size:parseInt(x[2]));
				if (last >= size) last=size-1;
				if (first >= size) first=size;
				if (last < first) {
					response.writeHead(416,"out of range");
					response.end();
					return;
				}
				else {
					response.writeHead(206, {
						'Content-Type': mime(f),
						'Content-Length': 1+last-first,
						'Content-Range': 'byte '+first+'-'+last+'/'+size
						});
					if (request.method == 'HEAD') {
						response.end();
						return;
					}
					var stream=fs.createReadStream(f,{start:first,end:last});
					stream.on('data',function(data){ response.write(data); });
					stream.on('end',function(){ response.end(); });
					stream.on('error',function(e){ response.end(); });
				}
			}
		}
	});
}


