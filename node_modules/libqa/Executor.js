/*
 * QA Executor class
 * Author: St√©phane Desneux <sdx@kooltux.org>
 * Date: 2013-05-05
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var strftime=require('strftime').strftimeUTC;

var logger=log4js.getLogger("qaexec");

var QA=require('libqa');

var DEBUG=false;

/* globals */
var CONFIG=null;

/*
MANAGEMENT OF EXECUTORS PLUGINS
===============================
*/

var methodsCheck = {
    /* config */
    setId: true,
    setOutput: true,
    setDryrun: true,

    /* ops */
    prepare: true,
    execute: true,
    getResult: true,
    cleanup: true
};

/* -------------- Executor class --------------------- */
 
var Executor=module.exports=function(opts) {
	var cfg=_.extend({
		configdir: null, 		// mandatory (where are the config files ?)
		name: "default", 		// optional (how to execute: from etc/test_exec.conf)
		output: QA.GLOBALS.local_tempdir, // optional output dir
		dryrun: false			// optional do-nothing flag
	},opts);
	DEBUG && logger.debug("Creating QA Executor with options: "+util.inspect(cfg));

	// instanciate config object
	CONFIG=new QA.Config(cfg.configdir);

	// check executor name
	if (!(cfg.name in CONFIG.EXECUTORS)) 
		throw new Error("Executor name '"+cfg.name+"' not found in config");
	this.name=cfg.name;

	// get plugin
	if (!('plugin' in CONFIG.EXECUTORS[this.name]))
		throw new Error("Executor '"+cfg.name+"' has no plugin (check config)");
	this.pluginName=CONFIG.EXECUTORS[this.name].plugin;

	// load plugin
	this.pluginClass=this._get_plugin(this.pluginName);
	this.pluginOptions=_.extend({},CONFIG.EXECUTORS[this.name]); // copy object
	delete this.pluginOptions['plugin']; // remove plugin name (unused in instance)
	// the remaining properties are considered as instance options

	// output dir or file
	this.output=cfg.output;

	// generate id 
	this.id=[
		this.name,
		strftime("%Y%m%d_%H%M%SU")
	].join("_");

	// dry run flag
	this.dryrun=cfg.dryrun ? true : false;

	// create plugin
	this.pexec=new this.pluginClass(this.pluginOptions);
	this.pexec.setId(this.id);
	this.pexec.setOutput(this.output);
	this.pexec.setDryrun(this.dryrun);
}

/* ----------------------- methods --------------------- */

Executor.prototype._get_plugin=function(name){
	name=name.toUpperCase();

	var klass;
	logger.info("Loading Executor plugin: "+name);
	try {
		klass=require("./executors/"+name+".js");
	}
	catch(e){
		throw new Error("Can't get executor plugin '"+name+"'\nReason: "+e.toString());
	}

	DEBUG && logger.debug("Loaded executor plugin: "+name);
	
	for(var m in methodsCheck) {
		if (methodsCheck[m] && !(typeof klass.prototype[m] == 'function'))
			throw new Error("Bad executor plugin: mandatory method '"+m+"' isn't defined.");
	}

	return klass;
}

Executor.prototype.setDryRun=function(dry) {
	this.dryrun=dry ? true : false;
	this.pexec.setDryrun(this.dryrun);
}

// operations forwarded to plugin

Executor.prototype.prepare=function(ctx,cb) {
    logger.info("Executor: prepare");
    this.pexec.prepare(ctx,_.bind(function(err) {
		if (err)
			throw err;
		this._prepared=true;
		cb();
    },this));
}

Executor.prototype.execute=function(ctx,cb) {
    logger.info("Executor: execute");

    if (!this._prepared) {
		throw new Error("execute() called without calling prepare()");
    }

    this.pexec.execute(ctx,_.bind(function(err) {
		if (err)
			throw err;
		cb();
    },this));
}

Executor.prototype.mergeResults=function(ctx,cb) {
    logger.info("Executor: mergeResults");
    this.pexec.mergeResults(ctx,_.bind(function(err) {
		if (err)
			throw err;
		cb();
    },this));
}

Executor.prototype.getResult=function(ctx,cb) {
    logger.info("Executor: getResult");
    this.pexec.getResult(ctx,_.bind(function(err) {
		if (err)
			throw err;
		cb();
    },this));
}

Executor.prototype.cleanup=function(ctx,cb) {
    logger.info("Executor: cleanup");
    this.pexec.cleanup(ctx,_.bind(function(err) {
		this._prepared=false;
		if (err)
			throw err;
		cb();
    },this));
}

