/*
 * QA Database class
 * Author: St√©phane Desneux <sdx@kooltux.org>
 * Date: 2013-01-10
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var path=require("path");
var fs=require('fs');

var logger=log4js.getLogger("qadb");

var QA=require('libqa');

var DEBUG=false;

var qaMetaFilePattern = /^QAMETA(.*)\.json$/


/**************** A database is for a directory ***************/

/* creates the database for the root directory 'basedir' */
var Database=module.exports=function(basedir) {
	// check dir
	if (!fs.statSync(basedir).isDirectory())
		throw new Error("qadb: invalid database dir '"+basedir+"'");

	this.root=new TestDir(path.resolve(basedir));
	this.root.refresh();

	DEBUG && logger.debug("Creating QA tests db from basedir "+basedir);
}

/* get the root directory of the database */
Database.prototype.getDir=function() {
	return this.root.dirpath;
}

/**************** util functions to walk in db tree ***************/

/* 
Enumerate the objects of the database by walking its filesystem,
starting with the subdirectory given by the optional argument 'subdir'
of the root directory. For each object (file or directory), the callback
function 'cb' is called (without this, i.e. this==null) with an
object as follow {
    basedir: String = root directory path
    subdirs: Array = relative path to the directory of the object
    name: String = name of the database object
    path: String = path of the database object
    isDir: Boolean = true if object is a directory
}
The several ways of calling the function:
    db.walk()           is like    db.walk("",function(){})
    db.walk("a/b")      is like    db.walk("a/b",function(){})
    db.walk(cb)         is like    db.walk("",cb)
    db.walk("a/b",cb)   is like    db.walk("a/b",cb) (its self!:)
*/
Database.prototype.walk=function(subdir,cb) {
	if (typeof subdir == 'function') {
		cb=subdir;
		subdir="";
	}
	if (typeof cb != 'function') {
		cb=function(){};
	}
	var subdirs=subdir.split("/").filter(function(x) { return (x!=""); });
	this._walk(this.getDir(),subdirs,cb);
}

/* private method to implement the method 'walk' */
Database.prototype._walk=function(basedir,subdirs,cb) {
	var dir=path.join(basedir,path.join.apply(null,subdirs));

	// check if dir is a real directory
	var stat=fs.statSync(dir);
	if (!stat.isDirectory()) return;

	fs.readdirSync(dir).sort().forEach(function(item) {
		var objpath = path.join(dir,item);
		stat=fs.statSync(objpath);

		var obj={
			basedir: basedir,
			subdirs: subdirs.slice(0),
			name: item,
			path: objpath,
			isDir: false
		};

		if (stat.isFile()) {
			cb.call(null,obj);
		}
		else if (stat.isDirectory()) {
			obj.isDir=true;
			cb.call(null,obj);

			var subdirs2=subdirs.concat([item]);
			this._walk(basedir,subdirs2,cb);
		}
	},this);
}

/***************** find test sets *******************/

/*
Return an Array of objects of type QA.Testset. 
The QA.Testset returned are those that are in the
subdirectory 'subdir' of the root directory of the database.
The function 'filterTestcaseFunc' is passed to the 'applyFilter'
method of the selected QA.Testset to remove unwanted test.
The several ways of calling the function:
    db.getTestsets()           is like   db.getTestsets("",function(){return true;})
    db.getTestsets("a/b")      is like   db.getTestsets("a/b",function(){return true;})
    db.getTestsets(cb)         is like   db.getTestsets("",cb)
    db.getTestsets("a/b",cb)   is like   db.getTestsets("a/b",cb) (its self!:)
*/

Database.prototype.getTestsets=function(subdir,filterTestcaseFunc) {
	if (typeof subdir == 'function') {
		filterTestcaseFunc=subdir;
		subdir="";
	}
	if (typeof filterTestcaseFunc != 'function') {
		filterTestcaseFunc=function() {return true;}
	}

	var sets=[];

	this.root.refresh().get(subdir).walkDown(function(tdir){
		if (tdir.isRoot()) return;
		var tset = new QA.Testset(tdir);
		tdir.forEachQaMeta(function(filename,name){
			// read file
			var obj, meta=fs.readFileSync(filename);
			//DEBUG && logger.debug(filename+": "+meta);
			// load as json object
			try {
				/* read the object */
				obj=JSON.parse(meta);
			}
			catch(e) {
				logger.warning("Invalid meta file "+filename+": "+e);
				return;
			}
			tset.addCases(QA.utils.splat(obj),name);
		});
		// apply restriction filter (reduces test cases number)
		tset.applyFilter(filterTestcaseFunc);
		if (!tset.isEmpty()) {
			sets.push(tset);
		}
	});

	return sets;
}

Database.prototype.getTarFileList=function(testsets) {
	QA.utils.pushd(this.getDir());
	var result=[];
	this.root.walkDown(function(td){td.used=false;});
	testsets.forEach(function(ts){
		var td = ts.set.testdir;
		result.push(td.path);
		/* what follow use property of root recursion */
		td.used=true;
		td=td.upperDir;
		while(!td.used) {
			td.used=true;
			fs.readdirSync(td.path||".").forEach(function(name) {
				var n=path.join(this.path,name);
				if(fs.statSync(n).isFile())
				    result.push(n);
			},td);
			td=td.upperDir;
		}
	});
	QA.utils.popd();
	return result;
}

/*
Call the function 'cb' with as follow: cb(retcode,version,log) where
'version' is the git version of the database (from its root directory),
'log' is the 5 last git log pretty printed and 'retcode' is the exit status 
of the git command (here zero).
*/
Database.prototype.getVersion=function(cb) {
	// cb is called with: err,version,infos
	
	var origdir=process.cwd();
	process.chdir(this.getDir());

	QA.utils.spawn(
		// git log -n 1 "--pretty=format:%ci - %h%n%cn (%ce)%n%s
		"db version",
		"git",
		[
			"log",
			"-n",5,
			"--pretty=format:%ci - %h%n%cn ([[mailto:%ce %ce]])%n%s%n"
		],
		function(rc,outbuf,errbuf) {
			process.chdir(origdir);

			var lines=outbuf.split("\n");
			var version=(lines.length ? lines[0] : "unknown");

			cb(rc,version,outbuf);
		},
		function(err) {
			// not a git: continue anyway
			cb(0,"unknown","");
		}
	);
}

/***************** Database.TestDir *******************/

/*
Creation of a TestDir (also named Database.TestDir).
The creation can be called in two ways:
 - for the root of the test directories: TestDir(dirpath)
 - for sub test directories: TestDir(dirpath,name,upper)
Where:
 - 'dirpath' (String): the path to the subirectory
 - 'name' (String): 
  
*/
var TestDir = Database.TestDir = function(dirpath,name,upper) {
	/* check existing directory */
	if (!fs.statSync(dirpath).isDirectory())
		throw new Error("Invalid test directory path '"+dirpath+"'.");

	/* records basic data */
	this.dirpath = dirpath;
	this.subDirs = {};
	this.subDirsArray = [];
	this.testset = null;
	this.paths={};

	/* records other data */
	if (!name && !upper) {
		/* creation of the root test directory */
		this.name = "";
		this.shortname = "";
		this.prefix = "";
		this.path = "";
		this.upperDir = this;
	}
	else if (name && upper) {
		/* creation of the sub test directory */
		if (!QA.utils.isTestDir(name))
			throw new Error("The name '"+name+"' isn't a valid test directory name.");

		this.name = name;
		this.shortname = QA.utils.stripName(name);
		this.prefix = QA.utils.getPrefix(name);
		this.upperDir = upper;
		if (upper.isRoot()) {
			this.path = name;
			this.component = this.shortname;
			this.id = this.prefix;
		}
		else {
			this.path = path.join(upper.path,name)
			this.component = path.join(upper.component,this.shortname);
			this.id = upper.id+"-"+this.prefix;
		}
	}
	else {
		throw new Error("Invalid call for root test directory.")
	}
	DEBUG && logger.debug("Creating TestDir from "+dirpath);
}

/*
Returns true if 'this' is the root TestDir.
*/
TestDir.prototype.isRoot = function() {
	return this.upperDir === this;
}

/*
Returns the root testdir
*/
TestDir.prototype.getRoot = function() {
	var result=this;
	while(result!==result.upperDir)
		result=result.upperDir;
	return result;
}

/*
Internal method called when refreshing directories.
'subname' is the name of a file in 'this' directory.
If 'subname' is a valid test directory name and is a directory
then the TestDir for the 'subname' is, if needed, created and added.
*/
TestDir.prototype.__check_and_add_if_needed = function(subname) {
	if (QA.utils.isTestDir(subname)) {
		var objpath = path.join(this.dirpath,subname);
		if (fs.statSync(objpath).isDirectory()) {
			if (!(subname in this.subDirs)) {
				var td = new TestDir(objpath,subname,this);
				this.subDirs[subname] = td;
				this.subDirsArray.push(td);
			}
		}
	}
}

/*
Internal method called when refreshing directories.
'td' is a TestDir of index 'idx' within 'this.subDirsArray'.
The method removes the 'td' TestDir if it doesn't exists anymore.
*/
TestDir.prototype.__remove_if_invalid = function(td,idx) {
	if (td.upperDir != this || this.subDirs[td.name]!=td || this.subDirsArray[idx]!=td)
		throw new Error("Invalid call to purge.");
	if (!fs.statSync(td.dirpath).isDirectory()) {
		delete this.subDirs[td.name];
		this.subDirsArray.splice(idx,1);
	}
}

/*
Internal method called when refreshing directories.
Refresh the contents of 'this' TestDir.
By default, the sub-TestDir-s are also refreshed, but if 'notRecursive' 
is true, then the sub-TestDir-s aren't refreshed.
*/
TestDir.prototype.__refresh = function() {
	/* remove invalid sub-TestDir-s */
	this.subDirsArray.forEach(this.__remove_if_invalid,this);
	/* add untracked sub-TestDir-s */
	fs.readdirSync(this.dirpath).forEach(this.__check_and_add_if_needed,this);
	/* sort the sub-TestDir-s */
	this.subDirsArray.sort(function(tda,tdb){return tda.name < tdb.name ? -1 : 1;});
}

/*
Internal recurssive walk function.
Call the 'callback' function with this set to the TestDir
object. 
*/
TestDir.prototype.__walk = function(callback) {
	callback.call(this);
	this.subDirsArray.forEach(function(td,i,a){td.__walk(callback);});
}

/*
Refresh the contents of 'this' TestDir.
By default, the sub-TestDir-s are also refreshed, but if 'notRecursive' 
is true, then the sub-TestDir-s aren't refreshed.
*/
TestDir.prototype.refresh = function(notRecursive) {
	if (notRecursive===true)
	    this.__refresh();
	else
	    this.__walk(this.__refresh);
	return this;
}

/*
Call the 'callback' function with this set to 'thisArg' for
the TestDir and all its sub-TestDir-s recurssively.
*/
TestDir.prototype.walkDown = function(callback,thisArg) {
	callback.call(thisArg,this);
	this.subDirsArray.forEach(function(td,i,a){td.walkDown(callback,thisArg);});
	return this;
}


/*
Call the 'callback' function with this set to 'thisArg' for
the TestDir and all its parents recurssively.
*/
TestDir.prototype.walkUp = function(callback,thisArg) {
	callback.call(thisArg,this);
	if (!this.isRoot())
		this.upperDir.walkUp(callback,thisArg);
	return this;
}

/*
Get the TestDir object 'result' such that  'result.path'=='path'.
Returns null in case of error.
*/
TestDir.prototype.get = function(path) {
	/* sub-optimal implementation but does it care? */
	var result = null;
	this.__walk(function(){if(this.path==path)result=this;});
	return result;
}

/*
Enumerate the QAmeta files of 'this' TestDir.
For each of the file that matches the definition of a QA meta
file, the 'callback' function is called with this set to 'thisArg'
and with the parameters ('filename','name','td') where 'name' is the
name of the filename wihin its directory, 'filename' is the
full path of the file, and 'td' is 'this' TestDir object.
And where, by definition, 'path.basename(filename)' == 'name'.
*/
TestDir.prototype.forEachQaMeta = function(callback,thisArg) {
	/* dont enumerate the QA meta of root */
	if (this.isRoot())
	    throw new Error("The root test directory doesn't contain any QAMETA file.")

	/* else it is okay */
	fs.readdirSync(this.dirpath).sort().forEach(function(name){
		    if (qaMetaFilePattern.test(name)) {
			    var filename=path.join(this.dirpath,name);
			    if (fs.statSync(filename).isFile()) {
				    callback.call(thisArg,filename,name,this);
			    }
		    }
	},this);
	return this;
}


/*
Returns the relative path of the directory of the testset.
*/
TestDir.prototype.getDirPath=function(prefix) {
	if(prefix===null)return this.dirpath;
	return this.__prefixed_paths(prefix).dir;
}

/*
Returns the exec path within the directory of the testset.
*/
TestDir.prototype.getExecPath=function(prefix) {
	return this.__prefixed_paths(prefix).exec;
}

/*
Returns the internal structure recording the prefixed paths.
*/
TestDir.prototype.__prefixed_paths=function(prefix) {
	if(prefix===null)
		prefix=this.getRoot().dirpath;
	else if(!prefix)
		prefix=""
	var result = this.paths[prefix];
	if(!result){
		if(this==this.upperDir){
			//@root
			result={
			    dir:    prefix,
			    exec:   prefix
			};
		}
		else{
			//!@root
			var p=prefix ? path.join(prefix,this.path) : this.path;
			result={
			    dir:    p,
			    exec:   p+":"+this.upperDir.__prefixed_paths(prefix).exec
			};
		}
		this.paths[prefix]=result;
	}
	return result;
}

/*
Return the component name of the testdir
*/
TestDir.prototype.getComponentName=function() {
	/* no component name for root */
	if (this.isRoot())
	    throw new Error("The root test directory has no component name.");

	return this.component;
}

/*
Return the id of the testdir
*/
TestDir.prototype.getId=function() {
	/* no component name for root */
	if (this.isRoot())
	    throw new Error("The root test directory has no id.");

	return this.id;
}

/*
Return the name of the testdir
*/
TestDir.prototype.getName=function() {
	return this.name;
}

/*
Return the shortname of the testdir
*/
TestDir.prototype.getShortName=function() {
	return this.shortname;
}
