/*
 * QA Utils
 * Author: St√©ane Desneux <sdx@kooltux.org>
 * Date: 2013-01-10
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var log4js=require("log4js");
var spawn = require('child_process').spawn
var _=require('underscore');

var logger=log4js.getLogger("qautils");

var DEBUG=false;

/*-------- Management of encoded name ----------------------*/

var base36="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var testDirValidator = /^[0-9A-Z][0-9A-Z]-/

/*
'ordname' is a string like 'XX-name' where XX is
a 36 base encoded value.
Return true if 'ordname' conforms to this definition.
*/
module.exports.isTestDir=function(ordname) {
	return testDirValidator.test(ordname);
}

/*
'ordname' is a string like 'XX-name' where XX is
a 36 base encoded value.
Return the 'name' component of 'ordname'.
*/
module.exports.stripName=function(ordname) {
	if (testDirValidator.test(ordname)) return ordname.slice(3);
	throw new Error("Unstrippable ordname '"+ordname+"'")
}

/*
'ordname' is a string like 'XX-name' where XX is
a 36 base encoded value.
Return the 'XX' component of 'ordname'.
*/
module.exports.getPrefix=function(ordname) {
	if (testDirValidator.test(ordname)) return ordname.slice(0,2);
	throw new Error("Unprefixable ordname '"+ordname+"'")
}

/*
Return an array containing the stripped names
contained in the array 'dirs'. See 'stripName'.
*/
module.exports.stripPath=function(dirs) {
	return dirs.map(module.exports.stripName);
}

/*
Return an array containing the prefix names
contained in the array 'dirs'. See 'getPrefix'.
*/
module.exports.pathToId=function(dirs) {
	// convert ['AA-foo','BB-bar','CC-baz'] to 'AA-BB-CC'
	return dirs.map(module.exports.getPrefix).join("-");
}

/*
Returns the string 'XX-name' where XX is the 36 base encode of num
and 'name' is 'name'.
*/
module.exports.encodeName=function(num,name) {
	if (num >= (36*36)) {
		throw new Error("Unable to encode object name if order num >= "+(36*36));
	}

	// from a number and a name, encode XX-name
	var low = num % 36;
	var upp = (num - low) / 36;

	return base36[upp]+base36[low]+"-"+name;
}

/*------------------------------------------------*/

/* Filter Not Empty String */
module.exports.fnes=function(x) {
	return x && (typeof x == 'string'); 
}

/*------------------------------------------------*/

/*
Execute the command "shell" 'cmd' with arguments 'args' (an array).
Then, it calls 'cb' on success or calls 'errcb' (if given) on error. 
It is an error when the command 'cmd' returns an exit code not null. 
Both callbacks 'cb' and 'errcb' are called with arguments (retcode,out,err,outerr)
where:
    - retcode is the returned exit code
    - out is the output (stdout) of the command
    - err is the error (stderr) of the command
    - outerr is the output and the error of the command joined together
As a special case, if the errcb function returns the string 'continue', the 
function 'cb' is then called. 
As an other special case, if the errcb isn't a function but is the string 'pass', the 
function 'cb' is called. 
*/
module.exports.spawn=function(desc,cmd,args,cb,errcb,outcb) {
	logger.info("Spawning subprocess "+desc+": "+cmd+" "+args.join(" "));

	var cmd=spawn(cmd,args);
	var bufs={
		out: "",
		err: "",
		outerr: ""
	};
	cmd.stdout.on('data',function(data) { 
		bufs.out+=data; bufs.outerr+=data; DEBUG && logger.debug(desc+"(I):"+data); 
		if (outcb) outcb(data);
	});
	cmd.stderr.on('data',function(data) { 
		bufs.err+=data; bufs.outerr+=data; DEBUG && logger.debug(desc+"(E):"+data); 
		if (outcb) outcb(data);
	});
	cmd.on('error',function(err) {
		logger.error("Subprocess failed: "+err);
		logger.error("Subprocess output: "+bufs.outerr);
		throw err;
	});
	cmd.on('exit',function(retcode) {
		if (retcode != 0) {
			if (!errcb) 
				throw new Error(desc+" failed with rc "+retcode+":"+bufs.outerr);
			else if(errcb=='pass')
				logger.info(desc+" raised error but should continue");
			else if (errcb(retcode,bufs.stdout,bufs.stderr,bufs.outerr) == 'continue')
				logger.info(desc+" completed after error recovery");
			else
				return;
		}
		else
			logger.info(desc+" completed successfully");

		cb(retcode,bufs.out,bufs.err,bufs.outerr);
	});
}

/*------------------------------------------------*/

var dirstack=[];

/*
Set the working directory to 'dir' but before that,
records in a stack the current working dir such that
a call to 'popd' restore it.
*/
module.exports.pushd=function(dir) {
	dirstack.push(process.cwd());
	process.chdir(dir);
}

/*
Restore the working directory saved by the previous 'pushd'.
*/
module.exports.popd=function() {
	process.chdir(dirstack.pop());
}

/*------------------------------------------------*/

/*
Ensure that 'x' is an array. If 'x' is an Array then it 
returns 'x' else it returns an array containing only 'x'.
*/
module.exports.splat=function(x) {
	return (x instanceof Array) ? x : [ x ];
}

/*------------------------------------------------*/

// helper func to convert a js object to python (or cats ?) syntax
var obj2py=module.exports.obj2py=function(obj) {
	function escquotes(v) { 
		if (typeof v != 'string') {
			if ((v === null) || (typeof v == 'undefined')) 
				v='null';
			else
				v=v.toString();
		}

		v=v.replace(/([^\x20-\x7F])/g,function(x) { 
			var hex=(x.charCodeAt(0).toString(16));
			if (hex.length==1)  hex="0"+hex; // pad
			return "\\x"+hex;
		});
		return "'"+v.replace(/'/g,"\\'")+"'"; 
	}

	if (obj instanceof Array) {
		return "["+obj.map(obj2py).join(",")+"]";
	}
	if (obj === null) {
		return "'null'";
	}
	if (typeof obj == 'object') {
		return "{"+
		    _.keys(obj).map(function(k) {
			return escquotes(k)+":"+obj2py(obj[k]);
		    }).join(",")+
		"}"
	}

	return escquotes(obj);
}



