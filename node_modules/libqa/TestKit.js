/*
 * QA TestKit class
 * Author: Jose Bollo <jobol@nonadev.net>
 * Date: 2013-01-29
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var util=require('util');
var log4js=require("log4js");
var path=require("path");
var fs=require('fs');
var XMLWriter = require('xml-writer');

var logger=log4js.getLogger("qatkit");

var QA=require('libqa');

var DEBUG=true;

/* typical XML:
 *
	<test_definition>
		<suite name="tizenpc/xxx">
			<set name="yyy">
				<testcase id="zzz" priority="0" execution_type="auto" status="approved" type="functional_positive" purpose="describe something">
					<description>
						<pre_condition />
						<post_condition />
						<steps>
							<step order="0">
								<step_desc>useless</step_desc>
								<expected>useless</expected>
							</step>
						</steps>
						<test_script_entry test_script_expected_result="0">/usr/bin/echo "Hello World"</test_script_entry>
					</description>
				</testcase>
				<testcase...>
					...
				</testcase>
			</set>
		</suite>
	</test_definition>
*/
/*
Builds a TestKit object.
*/

var basepath="";
var xwcore=null;
var testkitcorefile = "testkit.xml";
var testkitwebfile = "";
var testkit_file_list = []; // table of objects { name : "setname", isweb: boolean }

module.exports.createXML=function(testsuite) {

	basepath=path.join(
		QA.GLOBALS.hwtarget_rundir,
		QA.GLOBALS.tarball_topdir
	);

	var xw=new XMLWriter(true);

	xw.startDocument();
	    xw.startElement("test_definition");

		xw.startElement("suite");
		xw.writeAttribute("name",testsuite.getName());

		    testsuite.forEachTestset(writeTestSet,xw);

		xw.endElement("suite");
	    xw.endElement("test_definition");
	xw.endDocument();
	return xw.toString();
}

module.exports.createXMLFiles=function(executorname, profile, testsuite, testkitxmlpath) {
    if (executorname === "package") {
	logger.info("Creating XML files with the 'package' executor");
	basepath = path.join(QA.GLOBALS.hwtarget_packdir, profile.name, QA.GLOBALS.tarball_topdir);
    }
    else {
	logger.info("Creating XML files with the 'default' executor");
	basepath=path.join(QA.GLOBALS.hwtarget_rundir,QA.GLOBALS.tarball_topdir);
    }

    testkitcorefile = path.join(testkitxmlpath, testkitcorefile);
    xwcore=new XMLWriter(true);
    xwcore.startDocument();
	xwcore.startElement("test_definition");
            xwcore.startElement("suite");
		xwcore.writeAttribute("name",testsuite.getName());

    testsuite.forEachTestset(function(tset,tsuite) {

		if (tset.isWebSet()){
			writeWebXML(tset, tsuite, testkitxmlpath);
		}
		else {
			writeCoreXML(tset, testkitxmlpath);
		}
    });

	    xwcore.endElement("suite");
	xwcore.endElement("test_definition");
    xwcore.endDocument();

    xwcore.toString();
    DEBUG && logger.debug("Writing testkit file " + testkitcorefile);
    fs.writeFileSync(testkitcorefile, xwcore);
    testkit_file_list.push({name: path.basename(testkitcorefile), isweb: false});

    return testkit_file_list;
}

function writeCoreXML(tset, testkitxmlpath) {
    logger.info("set " + tset.getName() + " is core");
    xwcore.startElement("set");
	xwcore.writeAttribute("name",tset.getComponentName());

	   tset.forEachTestcase(writeCoreTestCase,xwcore);

    xwcore.endElement("set");
}
function writeWebXML(tset, tsuite, testkitxmlpath) {
    logger.info("Set " + tset.getName() + " is web");
    testkitwebfile = path.join(testkitxmlpath, tset.getShortName() + ".xml");
    logger.info("Generating XML instructions for set " + tset.getDirPath());
    var xweb=new XMLWriter(true);

    xweb.startDocument();
        xweb.startElement("test_definition");
            xweb.startElement("suite");
                xweb.writeAttribute("launcher","xwalk"); // attribute required to run web tests
                xweb.writeAttribute("name",tsuite.getName());

                xweb.startElement("set");
		    xweb.writeAttribute("name",tset.getComponentName());

                    tset.forEachTestcase(writeWebTestCase,xweb);

                xweb.endElement("set");
            xweb.endElement("suite");
        xweb.endElement("test_definition");
    xweb.endDocument();
    xweb.toString();

    logger.info("Testkit XML of set " + tset.getDirPath() + " generated");

    DEBUG && logger.debug("Writing testkit file " + testkitwebfile);
    fs.writeFileSync(testkitwebfile, xweb);
    testkit_file_list.push({name: path.basename(testkitwebfile), isweb: true});
}

/*
Emits into 'xw' the XML testkit data for the 'ts' testset.
*/
function writeTestSet(ts) {
	var xw=this;

	xw.startElement("set");
	xw.writeAttribute("name",ts.getComponentName());

	    ts.forEachTestcase(writeTestCase,xw);

	xw.endElement("set");
}


/*
Emits into 'xw' the XML testkit data for the 'tc' testcase.
*/
function writeCoreTestCase(tc) {

	var xw=this;
	var purpose=[
			"Objective: "+(tc.objective || "<not defined>"),
			"Description: "+(tc.description || "<not defined>")
		].join(" - ");

	xw.startElement("testcase");
		xw.writeAttribute("id",tc.getId());
		xw.writeAttribute("name",tc.name);
		xw.writeAttribute("priority","P"+tc.priority);
		xw.writeAttribute("execution_type",tc.exec_type);
		xw.writeAttribute("component",tc.getComponentName());
		xw.writeAttribute("status",tc.status);
		xw.writeAttribute("type",tc.type);
		xw.writeAttribute("purpose",purpose);

		xw.startElement("description");
			// pre and post conditions are only available for manual tests
			if (tc.pre_condition && tc.pre_condition.length) {
				xw.startElement("pre_condition");
					xw.writeCData(purpose + tc.pre_condition);
				xw.endElement();
			}
			else {
				xw.startElement("pre_condition");
					xw.writeCData(purpose);
				xw.endElement();
			}

			if (tc.post_condition && tc.post_condition.length) {
				xw.startElement("post_condition");
					xw.writeCData(tc.post_condition);
				xw.endElement();
			}
			if (tc.exec_type == "manual") {
				if (tc.steps && tc.steps.length) {
					xw.startElement("steps");
						tc.steps.forEach(function(s,idx) {
							xw.startElement("step");
								xw.writeAttribute("order",''+idx);
								
								if ('description' in s) {
									xw.startElement("step_desc");
										xw.writeCData(s.description);
									xw.endElement();
								}
								if ('expected' in s) {
									xw.startElement("expected");
										xw.writeCData(s.expected);
									xw.endElement();
								}
							xw.endElement();
						},this);
					xw.endElement();
				}
			}

			// generate <notes> from notes and bugs field
			xw.startElement("notes");
				// interpret bugs
				xw.writeCData(
					[
						tc.notes,
						formattedBugs(tc)
					]
					.filter(QA.utils.fnes)
					.join("\n")
				);
			xw.endElement("notes");

			if (tc.exec_type == "auto") {
				xw.startElement("test_script_entry");
					xw.writeAttribute("test_script_expected_result", tc.exec_expected_retcode.toString());
					xw.writeAttribute("timeout", tc.exec_kill_timeout.toString());
					
					xw.writeCData(tc.getScript(basepath,";"));

				xw.endElement("test_script_entry");
			}

		xw.endElement("description");

	xw.endElement("testcase");
}

/*
Emits into 'xw' the XML testkit data for the 'tc' testcase : tc is a web testcase.
*/
function writeWebTestCase(tc) {

	var xw=this;
	var purpose=[
			"Objective: "+(tc.objective || "<not defined>"),
			"Description: "+(tc.description || "<not defined>")
		].join(" - ");

	xw.startElement("testcase");
		xw.writeAttribute("id",tc.getId());
		xw.writeAttribute("name",tc.name);
		xw.writeAttribute("priority","P"+tc.priority);
		xw.writeAttribute("execution_type",tc.exec_type);
		xw.writeAttribute("component",tc.getComponentName());
		xw.writeAttribute("status",tc.status);
		xw.writeAttribute("type",tc.type);
		xw.writeAttribute("purpose",purpose);
		// add onload_delay attribute if defined in tc
		// this attribute appears in some web test cases
		if (tc.onload_delay && tc.onload_delay != 0) {
		    xw.writeAttribute("onload_delay",tc.onload_delay);
		}

		xw.startElement("description");
			// pre and post conditions are only available for manual tests
			if (tc.pre_condition && tc.pre_condition.length) {
				xw.startElement("pre_condition");
					xw.writeCData(purpose + tc.pre_condition);
				xw.endElement();
			}
			else {
				xw.startElement("pre_condition");
					xw.writeCData(purpose);
				xw.endElement();
			}

			if (tc.post_condition && tc.post_condition.length) {
				xw.startElement("post_condition");
					xw.writeCData(tc.post_condition);
				xw.endElement();
			}
			if (tc.exec_type == "manual") {
				if (tc.steps && tc.steps.length) {
					xw.startElement("steps");
						tc.steps.forEach(function(s,idx) {
							xw.startElement("step");
								xw.writeAttribute("order",''+idx);
								
								if ('description' in s) {
									xw.startElement("step_desc");
										xw.writeCData(s.description);
									xw.endElement();
								}
								if ('expected' in s) {
									xw.startElement("expected");
										xw.writeCData(s.expected);
									xw.endElement();
								}
							xw.endElement();
						},this);
					xw.endElement();
				}
			}

			// generate <notes> from notes and bugs field
			xw.startElement("notes");
				// interpret bugs
				xw.writeCData(
					[
						tc.notes,
						formattedBugs(tc)
					]
					.filter(QA.utils.fnes)
					.join("\n")
				);
			xw.endElement("notes");

			if (tc.exec_type == "auto") {
				xw.writeElement("test_script_entry", tc.exec);
			}

		xw.endElement("description");

	xw.endElement("testcase");
}



/*
Returns the MediaWiki formatted links to bugs. 
*/
function formattedBugs(tc) {
	return tc.bugs
		.split(/\s+/)
		.filter(function(x) { return /\w+$/.test(x); }) // filter single "-" in bugs
		.map(function(x) { return "[[http://bugs.tizen.org/jira/browse/"+x+" "+x+"]]" })
		.join(" ")
	;
}

