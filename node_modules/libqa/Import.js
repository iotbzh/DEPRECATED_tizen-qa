/*
 * QA Import class
 * Author: St√©phane Desneux <sdx@kooltux.org>
 * Date: 2013-02-06
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var _s=require('underscore.string');
var util=require('util');
var log4js=require("log4js");
var path=require("path");
var fs=require('fs');
var strftime=require('strftime').strftimeUTC;
var mkdirp=require('mkdirp');
var csv=require("csv");

var logger=log4js.getLogger("qaimport");

var QA=require('libqa');

var DEBUG=false;

/* globals */
var CONFIG=null;

/* -------------- Import class --------------------- */
 
var Import=module.exports=function(opts) {
	var cfg=_.extend({
		configdir: null, 		// mandatory (where are the config files ?)
		dbdir: null ,			// mandatory (top db dir)
		input: "-"				// stdin
	},opts);
	DEBUG && logger.debug("Creating QA Import with options: "+util.inspect(cfg));

	// instanciate config object
	CONFIG=new QA.Config(cfg.configdir);

	// output dir or file
	this.input=cfg.input;

	// init database with dbdir
	this.db=new QA.Database(cfg.dbdir);

	// dry run flag
	this.dryrun=false;
}

/* ----------------------- methods --------------------- */

Import.prototype.enableDryRun=function() {
	this.dryrun=true;
}

Import.prototype.execute=function(options,cb) {
	options=_.extend({
		delimiter: ',',
	},options||{});

	logger.info("Import with options:\n"+util.inspect(options));

	var FS="\t";
	var LS="\n";

	// create readable stream
	var ins;
	if (this.input == "-") {
		ins=process.stdin;
	}
	else {
		ins=fs.createReadStream(this.input)
	}
	ins.setEncoding('utf8');
	ins.resume();

	// parse csv
	var err=false;
	var columns=false;
	var testcases={};
	var tccount=0;
	var self=this;

	csv()
	.from.stream(ins)
	.on('record',function(record) {
		if (err) return;

		// first row: get columns names
		if (!columns.length) {
			columns=record.map(_s.underscored);
			logger.info("Detected columns: "+columns.join(","));
			if(columns.every(function(x){return x!='path';})){
				logger.error("No column 'path' found");
				err=true;
				ins.destroy();
				return;
			}

			// check columns names
			var tc=QA.Testcase.GetDefault();
			columns.forEach(function(col) {
				if (!(col in tc)) {
					if (col == 'path') return; // special case

					logger.error("Invalid column '"+col+"'");
					err=true;
					ins.destroy();
				}
			});
			return;
		}

		// a real record with data
		var tc=_.extend( QA.Testcase.GetDefault(), _.object(columns,record) );

		// extract and adjust path
		var tcpath="";
		if ('path' in  tc) {
			tcpath=tc.path;
			delete tc.path;
			if (! /QAMETA.*?\.json$/.test(tcpath)) {
				tcpath=path.join(tcpath,"QAMETA.json");
			}
		}

		// transform steps
		var steps=(tc.steps||"").split(/\r?\n/);
		tc.steps=steps.map(function(s) {
			s=s.trim();
			if (!s.length) return;

			var so={};
			var elts=s.split("=>");
			so.description=(elts.length ? elts.shift().trim() : '');
			so.expected=elts.filter(function(x) { return x.length>0;}).join("=>").trim();

			return so;
		}).filter(function(x){return x;});

		// save in testcases list
		if (!(tcpath in testcases)) {
			testcases[tcpath]=[];
		}
		testcases[tcpath].push(tc);
		tccount++;
	})
	.on('error',function(e) {
		logger.error(e);
		err=e;
		ins.destroy();
	})
	.on('end',function() {
		DEBUG && logger.debug("End of input");
		if (err) {
			if (typeof cb == 'function') {
				cb(err);
			};
			return;
		}
		
		//DEBUG && logger.debug("Testcases: "+util.inspect(testcases));
		logger.info(tccount+" testcases loaded");

		self._saveTestcasesFiles(testcases,cb);
	});
}

Import.prototype._saveTestcasesFiles=function(testcases,cb) {
	_.keys(testcases).forEach(function(dbpath) {
		var filename=path.resolve(this.db.getDir(),dbpath);

		DEBUG && logger.debug("Creating filename "+filename+" with "+testcases[dbpath].length+" testcases");

		if (fs.existsSync(filename)) {
			logger.error("File "+filename+" already exist. Not overwriting.");
			return;
		}

		// create dir if not exist
		try {
			mkdirp.sync(path.dirname(filename));
		}
		catch(e) {
			logger.error(e);
			throw e;
		}
		
		fs.writeFileSync(filename,JSON.stringify(testcases[dbpath],null," "));
	},this);
	
	if (typeof cb == 'function') {
		cb(true);
	}
}


