/*
 * QA CSV Export class
 * Author: St√©phane Desneux <sdx@kooltux.org>
 * Date: 2013-03-01
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var _=require('underscore');
var _s = require('underscore.string');
var util=require('util');
var log4js=require("log4js");
var path=require("path");

var logger=log4js.getLogger("qaexpcsv");

var QA=require('libqa');

var DEBUG=false;

/* ------------------ plugin default options ---------------- */
var DEFAULTS={
	delimiter: ";",
	pkgroot:"",
	pkgstripdir: 0
};

/* ------------------ plugin class ---------------- */

var Plugin=module.exports=function(opts) {
	_.extend(this,
		_.extend(DEFAULTS,opts || {})
	);
}

Plugin.prototype.setId=function(id) {
	DEBUG && logger.debug("Plugin id: "+id);
	this.id=id;
}

Plugin.prototype.getFilename=function() {
	return "export_"+this.id+".csv";
}

Plugin.prototype.execute=function(testsuite,cb) {
	// build jsondata
	
	var fields=[
		"Order Number",
//		"Id",
//		"Number",
		"Package",
		"Name",
		"Execution_Type",
		"Priority",
		"Status",
		"Type",
//		"Estimated Duration In Minutes",
		"Created By",
//		"Assigned To",
		"Created At",
		"Last Updated At",
		"Objective",
		"Description",
		"Notes",
		"Pre Condition",
		"Post Condition",
		"Step Number",
		"Step Description",
//		"Step Data",
		"Step Expected Result",
//		"Step Notes",
		"Test_Script_Entry",
		"Test_Script_Expected_Result"
	];
	var rows=[];

	rows.push(fields);

	var ordnum=1;

	testsuite.forEachTestset(function(tset) {
		tset.forEachTestcase(function(tcase,tcidx) {
			// skip disabled testcases
			if (tcase.status == "disabled") return;

			var tc=tcase.toExportable();

			// build package from tc path
			var pkg=[];
			// use this.pkgroot first
			this.pkgroot.split("/").forEach(function(k) {
				k=k.trim();
				if (k.length) pkg.push(_s.capitalize(k));
			},this);

			// add tc fullname (first elements are removed if pkgstripdir>0)
			tc.pathname.split("/").forEach(function(k,idx) {
				if (idx<this.pkgstripdir)
					return;
				k=k.trim();
				if (k.length) pkg.push(k);
			},this);

			// finally, E.T. waits for packages separated by pipes
			pkg=pkg.join("|");

			// build base row
			var base={
				"Order Number": ordnum++,
				"Id": "", // generated
				"Number": "", // generated
				"Name": tc.name||"",

				"Package": pkg,
				"Priority": "P"+( (tc.priority>4) ? 4 : tc.priority ),
				"Status": _s.capitalize(tc.status),
				"Type": _s.capitalize(tc.type||"").replace(/_/g," "),
				"Estimated Duration In Minutes": "", // undefined
				"Created By": tc.author || "qavannes",
				"Assigned To": "",
				"Created At": (tc.ctime ? tc.ctime.substr(0,10) : "1970-01-01"),
				"Last Updated At": (tc.mtime ? tc.mtime.substr(0,10) : "1970-01-01"),
				"Description": tc.description||"",
				"Objective": tc.objective||"",
				"PreCondition": tc.pre_condition||"",
				"PostCondition": tc.post_condition||"",
				"Notes": (function() {
					var res=[];
					if (tc.notes && tc.notes!="-") res.push(tc.notes);
					if (tc.bugs && tc.bugs!="-") res.push("Bugs: "+tc.bugs)
					return res.join(" - ");
				})(tc),
				"Execution_Type": _s.capitalize(tc.exec_type||""),
				"Test_Script_Entry": tc.exec || "",
				"Test_Script_Expected_Result": (function(tc) { 
					var i=parseInt(tc.exec_expected_retcode);
					if (isNaN(i)) i=0;
					return i;
				})(tc)
			};

			if (tc.steps.length == 0) { // create at least one step
				tc.steps.push({
					description: "-",
					expected: "-"
				});
			}
			
			/* one row per step */
			tc.steps.forEach(function(step,idx) {
				// clone base row and add step info
				var dst=_.extend({
					"Step Number": idx+1,
					"Step Description": step.description || "-",
					"Step Data": step.data || "",
					"Step Expected Result": step.expected||"-",
					"Step Notes": step.notes || ""
				},base);

				rows.push(fields.map(function(k) { return ((k in dst) ? dst[k]:""); }));

				// clear base for next row
				base={};
			},this);

			/* merge all steps in one row */
			/* used in Christophe Prigent's template
			 * doesn't work on tz.otcshare.org/EnterpriseTester/
			 
			var steps={
				description: [],
				expected: [],
				data: [],
				notes: []
			};
			tc.steps.forEach(function(s,idx) {
				idx+=1;
				_.keys(steps).forEach(function(k) {
					steps[k].push(
						idx+
						". "+
						(
							( (k in s) && (typeof s[k] =='string') && s[k].length) ?
							s[k] :
							"-"
						)
					);
				});
			});
			
			_.extend(base,{
				"Step Number": 			steps.length,
				"Step Description": 		steps.description.join("\n") || "-",
				"Step Data": 				steps.data.join("\n"),
				"Step Expected Result": steps.expected.join("\n") || "-",
				"Step Notes": 				steps.notes.join("\n")
			});

			rows.push(fields.map(function(k) { return ((k in base) ? base[k]:""); }));
			*/

		},this); // forEachTestCase
	},this); // forEachTestSet

	// build csv
	var csv=[];
	rows.forEach(function(row,idx) {
		if (idx != 0) {
			row=row.map(function(v) {
				if (typeof v == 'number') return v; // no quote for numbers
				return '"'+String(v).replace(/"/g,'""')+'"';
			})
		}

		csv.push( row.join(this.delimiter) + "\n" );

	},this);

	cb(csv.join(""));
}

