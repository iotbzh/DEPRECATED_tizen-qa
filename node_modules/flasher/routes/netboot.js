/*
 * Controller for handling all actions related to datalogger
 *
 * Usually, those ops are sent to datalogger daemon
 * 
 * -------------------------------------------------------------------
 *
 * Copyright 2013, Intel Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

var log4js=require("log4js");
var logger=log4js.getLogger("netboot");
var net=require('net');
var HW=require('libhardware');

module.exports = function(app,prefix) {
	var wwwserv=this; // wwwserver instance
	
	// initialize target list
	var HWMGR=new HW.Manager(wwwserv.confdir);
	var TARGETS={};
	HWMGR.forEachDevice(function(dev) {
	    TARGETS[dev.ip_address]={
		ip: dev.ip_address,
		name: dev.hostname,
		product: dev.product,
		state: 'netboot'
	    };
	});

	// states:
	// netboot => flashing => localboot 
	function getTarget(ip) {
	    if (!(ip in TARGETS)) {
		TARGETS[ip]={
		    ip: ip,
		    name: ip,
		    product: 'unknown',
		    state: "netboot"
		};
	    }
	    return TARGETS[ip];
	}

	// declare routes on express app
	app.get(prefix+'state',function(req,res) {
		res.json(TARGETS);
	});
	
	app.get(prefix+'state/:ip',function(req,res) {
		var target=getTarget(req.params.ip);

		res.json(target);

	});

	app.get(prefix+'ipxe_script',function(req, res) {
		var baseurl=req.protocol+"://"+req.host+":"+wwwserv.port;
		
		logger.info("iPXE boot script request from "+req.ip);
		logger.info("Base URL: "+baseurl);

		// get target state
		var target=getTarget(req.ip);

		// retrieve current state
		logger.info("Target state: "+JSON.stringify(target));

		// choose right script
		var script;
		switch (target.state) {
			case "netboot":
				logger.info("Sending net boot script");

				script=[
					'#!ipxe',
					'echo "QA Server - Netboot script running for '+target.ip+'"',
					':retry_dhcp',
					'dhcp && isset ${filename} || goto retry_dhcp',
					'echo DHCP succeeded',
					'echo IP address: ${net0/ip}',
					'echo Subnet mask: ${net0/netmask}'
				];

				// push debian boot initrd and vmlinuz
				script.push('initrd '+baseurl+'/netboot/debian/initrd.img');
				script.push('chain '+baseurl+'/netboot/debian/vmlinuz boot=live fetch='+baseurl+'/netboot/debian/filesystem.squashfs config splash memtest qaserver='+baseurl);
				script.push("");

				script=script.join("\n");
				break;

			case "localboot":
				logger.info("Sending local boot script");
				script=[
					'#!ipxe',
					'echo "QA Server - Localboot script running for '+target.ip+'"',
					'sanboot --no-describe --drive 0x80',
					''
				].join("\n");

				// force netboot state to flash on next reboot
				target.state="netboot";
				break;

			default:
				logger.error("Unknown target state for iPXE: "+target.state);
				logger.info("Sending reboot script");
				script=[
					'#!ipxe',
					'echo "QA Server Script running"',
					'echo "State is unknown: Rebooting..."',
					'reboot',
					''
				].join("\n");

				// restore initial state
				target.state="netboot";
				break;
		}

		res.setHeader('Content-Type', 'text/plain');
		res.setHeader('Content-Length', script.length);
		res.end(script);
	});

	// called by targets to signal their state changes
	app.get(prefix+'event/waitflash/:port',function(req,res) {
		var target=getTarget(req.ip);
		var port=req.params.port || 514; // shell port

		if (target.state == "flashing") {
			// flashing process already started
			logger.info("Flash script currently running on "+req.ip+":"+port);
			res.end("RUNNING");
			return;
		}

		// start flashing image
		logger.info("Starting flash script on "+req.ip+":"+port);
		target.state="flashing";
		res.end("OK");

		var baseurl=req.protocol+"://"+req.host+":"+wwwserv.port;

		// build flash command with args
		var script=[
			"exec /root/flash_image",
			baseurl+"/netboot/flash_script.sh", // the script to retrieve
			baseurl+"/targets/"+req.ip+"/image.raw", // the image to flash
			baseurl+"/netboot/event/flashdone", // event url to call
		].join(" ")+"\n";

		// fork flash process
		setTimeout(function() {
			// connect on given port, send command and wait for exit
			var sock=new net.Socket();
			sock.on('error',function(err) {
				logger.error("Flash init: error - "+err);
			});
			sock.on('data',function(data) {
				logger.info("Flash init: "+data);
			});
			sock.on('end',function() {
				logger.info("Flash init: socket closed");
				sock.destroy();
			});
			sock.connect(port,req.ip,function() {
				logger.info("Starting flash script: "+script);
				sock.write(script);
			});
		},0);
	});

	app.get(prefix+'event/flashdone/:rc',function(req,res) {
		var target=getTarget(req.ip);

		logger.info("Flash script finished on "+req.ip+" - rc="+req.params.rc);

		if (req.params.rc == 0) {
			// change state
			target.state="localboot";
		}
		else {
			// restart flashing ?
			target.state="netboot";
		}

		logger.info("Target is now in state "+target.state);

		res.end("OK");
	});
};
